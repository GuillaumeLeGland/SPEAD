function [XarraySmooth,XarraySTD] = myrunmean2D(Xarray,winxyhalf)

%========================================================================
%........................................................................
X = Xarray;
%........................................................................
[ysize,xsize] = size(X); %[depth,time] or [lat,lon]
%........................................................................
%========================================================================
%........................................................................
winxh = winxyhalf(1); %lon or time
winyh = winxyhalf(2); %lat or depth
%........................................................................
winx = (2*winxh) + 1; %window size (it's always a odd number: 3,5,7,...etc)
winy = (2*winyh) + 1;
%........................................................................
winxy = [winy,winx]; %[depth,time] or [lat,lon] 
%........................................................................
winconv = ones(winxy); %window para la convolucion (matriz de 1's).
%........................................................................
pcnt = 1/3; %minimo porcentage de puntos necesario para hacer el smooth.
%........................................................................
ptosmin = floor(pcnt*prod(winxy)); %que haya al menos un 50% de datos en la widow "xwin * ywin * zwin".
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%COUNT NUMBER OF DATA POINTS WITHOUT TAKING NANs:
%[NOTE: Use with "mynanconv.m"]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%........................................................................
X01 = zeros(size(X));
Inan = find(isnan(X) == 1); %NAN data.
Inonan = find(isfinite(X) == 1); %non-nan data (zero is a valid value).
X01(Inonan) = 1; %Array with ones where valid data and zero otherwise.
%........................................................................

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%ENLARGE BOUNDARY CONDITIONS:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%========================================================================
%........................................................................
tmpX   = nan*ones(ysize+(winyh*2),xsize+(winxh*2));
tmpX01 = nan*ones(ysize+(winyh*2),xsize+(winxh*2));
%........................................................................
[ysizetmp,xsizetmp] = size(tmpX); 
%........................................................................
I = [1+winyh:ysizetmp-winyh]; %Middle values. 
J = [1+winxh:xsizetmp-winxh]; %Middle values. 
%........................................................................
I1 = fliplr([1:1+(winyh-1)]); %reverse order. 
I2 = fliplr([ysize-(winyh-1):ysize]);
%........................................................................
J1 = ([1:1+(winxh-1)]); 
J2 = ([xsize-(winxh-1):xsize]);
%........................................................................
MA = X;
MB = [MA(I1,:);MA(:,:);MA(I2,:)];
MC = [MB(:,J2),MB(:,:),MB(:,J1)];
tmpX = MC; 
%........................................................................
MA = X01;
MB = [MA(I1,:);MA(:,:);MA(I2,:)];
MC = [MB(:,J2),MB(:,:),MB(:,J1)];
tmpX01 = MC; 
%........................................................................
Xbis = tmpX(I,J); 
%........................................................................
% $$$ figure(10)
% $$$ subplot(2,2,1)
% $$$ imagesc(X)
% $$$ mycolorbar
% $$$ subplot(2,2,2)
% $$$ imagesc(tmpX)
% $$$ mycolorbar
% $$$ subplot(2,2,3)
% $$$ imagesc(Xbis)
% $$$ mycolorbar
% $$$ subplot(2,2,4)
% $$$ imagesc(tmpX01)
% $$$ mycolorbar
% $$$ pause
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%CONVOLUCION OVER THE DATA ARRAYS:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%========================================================================
%........................................................................
CX  = nanconvn(tmpX,      winconv,'same');   %E(X)=CX*(1/N)
CXX = nanconvn(tmpX.*tmpX,winconv,'same');   %E(Xexp2)=CXX*(1/N)
%........................................................................
% $$$ CX  = mynanconvn(tmpX,      winconv,'same');   %E(X)=CX*(1/N)
% $$$ CXX = mynanconvn(tmpX.*tmpX,winconv,'same');   %E(Xexp2)=CXX*(1/N)
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%CONVOLUCION OVER THE ZERO-ONES (NODATA/DATA) MASK-ARRAY:
%(JUST TO COUNT THE NUMBER OF POINTS USED IN THE CONVOL):
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%========================================================================
%........................................................................
N = convn(tmpX01,winconv,'same'); %n0 de ptos usados en la convolucion.
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%REMOVE THE PREVIOUSLY ADDED BORDER CONDITIONS:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%========================================================================
%........................................................................
N   = N  (I,J); %remove BC.
CX  = CX (I,J);
CXX = CXX(I,J);
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%COMPUTE RUNNING MEANS (SMOOTHING) AND ASSOCIATED VARIANCES: 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-----------------------------
%NOTE: VAR(X)=E(X^2)-(E(X))^2
%-----------------------------
%========================================================================
%........................................................................
In = find(N >= ptosmin); %positions(i,j,k) where more than (1/3) of points were taken by the window. 
%........................................................................
EX  = ones(ysize,xsize)*nan;  %E(X)
EX2 = ones(ysize,xsize)*nan;  %E(X^2)
VX  = ones(ysize,xsize)*nan;  %Var(X)
SX  = ones(ysize,xsize)*nan;  %Std(X)
%........................................................................
EX (In) = CX (In)./N(In); %E(X) = valores promdio en la window para el X
EX2(In) = CXX(In)./N(In); %E(X^2)
%........................................................................
VX(In) = EX2(In) - EX(In).^2; %var(Xsmooth)
VX(In) = fix(VX(In)*1d8)/1d8; %to avoid negative numbers due to precission issues. 
SX(In) = sqrt(VX(In));
%........................................................................
%========================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%PUT BACK THE NANs WHERE THEY WERE:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%========================================================================
%........................................................................
X (Inan)=nan; %PARA "globalPDR" PAPER USAR ESTOS!!!
EX(Inan)=nan;
SX(Inan)=nan;
%........................................................................
%========================================================================

%%%%%%%%
%OUTPUT:
%%%%%%%%
%========================================================================
%........................................................................
XarraySmooth = EX;
XarraySTD    = SX;
%........................................................................
%========================================================================
%************************************************************************
return

